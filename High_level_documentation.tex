%% LyX 2.3.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{float}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\providecommand{\algorithmname}{Algorithm}
\floatname{algorithm}{\protect\algorithmname}

\makeatother

\usepackage{babel}
\begin{document}

\title{Efficient Belief Revision with All-SAT}

\author{Aaron Hunter, John Agapeyev}
\maketitle
\begin{abstract}
We demonstrate an efficient and highly parallel Belief Revision solver
that utilizes an All-SAT solver for enumerating a list of satisfying
assignments to the revision formula. We describe the implementation
details and algorithms involved in the solver, as well as the technical
details and decisions that motivated its creation. We are able to
handle revision formulas with 100 variables, and our limit on processing
is the scale of solutions returned form the All-SAT solver, requiring
algorithmic improvements if we are to exceed our current boundaries.
\end{abstract}

\section{Introduction}

We introduce a new efficient solver for Belief Revision based on the
use of All-SAT solvers, and describe the algorithms and design choices
involved. The use of All-SAT solvers has never before been demonstrated
in existing literature on Belief Revision, and our solution is orders
of magnitude faster than previous tools. Our tool is designed from
the ground-up with a focus on efficient representation of data, and
scaling with multiple processing cores. This tool serves as a platform
that can be modified and adapted to show the implications of various
heuristics, and how they scale with large numbers of variables.

\section{Preliminaries}

\subsection{Background}

Belief Revision is the process in which an agent adapts its existing
beliefs in the face of new information. Let $K$ be the set of beliefs
for the agent, and let $\phi$ be the revision formula. Belief Revision
is the operator $\ast$ on $K$, shown as $K\ast\phi$ which returns
a new set of beliefs that have been revised based on the provided
formula.

\subsection{Implementation}

Our solver is written in modern C++17 for POSIX systems, and utilizes
OpenMP 4.5 for parallelism.

\section{Input}

\subsection{Interactive Mode}

Our solver has two primary methods of obtaining input data: Interactively,
and File based. The Interactive mode prompts the user for human readable
equations in order to obtain the initial belief states, as well as
the revision formula. Interactive mode operates based on a limited
subset of propositional logic consisting of only AND, OR, and NOT.
There is no distinction made as to the relative ordering of those
arguments, so user input is not forced into Conjunctive Normal Form
or any other formatted representations. Additionally, negations must
act only on the individual variables, and not on subexpressions, in
order to simplify the parsing. The user may subdivide the expression
using parentheses in order to force a particular evaluation order.
Variables are represented as positive integers, with additional variables
being implied based on the range of variable values. This means that
an expression such as \emph{1 and 10 }implies 10 total variables,
even though only 2 are listed in the expression. These implied variables
are assumed to exist, but have no particular value, since they are
unspecified. Our solver detects this and enumerates all possible assignments
to these variables in order to ensure logical correctness. Equations
are parsed using the Shunting Yard algorithm to convert the Infix
notation equation into a Postfix notation, which is then evaluated.
The resulting formula is generated by creating a truth table of the
function, and performing either the Sum of Products or Product of
Sums translation, depending on the desired output.

\subsection{File Input}

Our solver also accepts file-based input, in order to support large
scale and precalculated data sets. The solver accepts 3 different
formats of input: Conjunctive Normal Form, Disjunctive Normal Form,
and Raw Hexadecimal. The CNF and DNF formats are defined using the
DIMACS message format. Raw hexadecimal follows a similar convention
in regards to comments and requiring a problem line, but the data
is represented as hexadecimal strings, rather than space separated
values. Each hex digit naturally converts into 4 binary bits, which
are used to specify the assignments of variables. For example, the
hex string of ``0xa'' would correspond to 1010 in binary, which
would indicate to variables 1 and 3 being true, while 2 and 4 are
false. This can easily be used as a space-efficient representation
of an equation in Disjunctive Normal Form. The representation of data
internally is covered in more detail in Section 5. Initial belief
sets and the revision formula are in their own separate files, allowing
different representations of input data for the same problem. Internally,
all forms of data are convertable to each other, allowing flexibility
in the interface, without compromising efficiency in the solver implementation. 

\section{Revision}

Belief Revision is carried out with the following algorithm:

\begin{algorithm}[H]
\caption{Belief Revision}

\textbf{function} Revise($K$, $\phi$)
\begin{enumerate}
\item $S$ = generateStates($\phi$)
\item \textbf{if }$|\{S\cap K\}|$ > 0 \textbf{then return }$\{S\cap K\}$
\item $m$ = \emph{INT\_MAX}
\item $d=\min(\{S_{i}\in S:distance(S_{i},K)\})$
\item $O=\{S_{i}\in S:distance(S_{i},K)=d\}$
\item \textbf{return $O$}
\end{enumerate}
\end{algorithm}

\begin{enumerate}
\item generateStates() generates all possible state assignments that satisfy
the formula $\phi$.
\item distance() calculates the total pre-order of the state $S_{i}$ compared
to the existing beliefs $K$. Our solver natively supports Hamming
Distance, though it can use other pre-orders with minor modifications.
\end{enumerate}
Our use of an All-SAT solver is characterized in the generateStates()
function. Since we require the set of all satisfying assignments to
a list of variables given by some formula $\phi$, an All-SAT solver
works well, and can we can use algorithmic advances in such a solver
in order to increase efficiency in Belief Revision. The pseudocode
for generateStates() is given below:

\begin{algorithm}[H]
\caption{Generation of Satisfying States}

\textbf{function }generateStates($\phi$)
\begin{enumerate}
\item $b$ = $|\{k:k\in K\}|$
\item $S$ = All-SAT($\phi$)
\item \emph{a = }$|\{s:s\in S\}|$
\item \emph{O = $\{S\}$}
\item \textbf{if }\emph{a > b }\textbf{then return }\{\}
\item \textbf{if }\emph{a} < $b$\textbf{ then}
\begin{itemize}
\item \emph{O = \{\}}
\item \textbf{for }$S^{i}$ \textbf{in $S$ do}
\begin{itemize}
\item \emph{j }= 0
\item \textbf{while }\emph{j < (1 <\textcompwordmark < (b - a))} \textbf{do}
\begin{itemize}
\item \emph{L} = \emph{a} 
\item \textbf{while }\emph{L < b }\textbf{do}
\begin{itemize}
\item $S^{i}[L]$ = j \& (1 <\textcompwordmark < \emph{(L - a))}
\item \emph{L = L + }1
\end{itemize}
\item \textbf{end while}
\item \textbf{if }satisfies($S^{i},\phi$) \textbf{then }\emph{O = \{O,
$S^{i}$\}}
\item j = j + 1
\end{itemize}
\item \textbf{end while}
\end{itemize}
\item \textbf{end for}
\end{itemize}
\item \textbf{endif}
\item \textbf{return }$O$
\end{enumerate}
\end{algorithm}

Primarily, the state generation is done by the All-SAT solver. The
remainder of the algorithm is for padding the resulting states. For
the total pre-order to function correctly, the generated states must
contain the same number of variables as the comparison states. This
discrepancy is what prompts the remainder of the algorithm, which
is essentially a bitwise brute-force of the remaining variables. This
creates every possible satisfying state equal to the length of the
original beliefs. A difference in the generated and output states
is a result of the provided formula not containing all possible variables
in its definition.

\section{Design Decisions}

Our goal with this solver is in creating a highly optimized and efficient
solver, that sports both algorithmic and implementation optimizations.
The use of an All-SAT solver provides significant algorithmic speedups,
but the implementation decisions are not so simple. There are two
primary aspects involved in creating an efficient runtime. The first
is on the reprsentation of data. Since the algorithm functions on
variable states, and logical formulae, there needed to be a quick
format of accessing and modifying the data, since these operations
consist the bulk of work of the solver. Due to our use of an All-SAT
solver, the revision formula needs to be in a format that the All-SAT
solver can use. As such, we store the revision formula exactly in
CNF as the DIMACS format provides it. The data is stored as a two-dimensional
array of integers, with each integer representing the 1-indexed variable
number, and a negative number represents the logical negation of that
variable. Each subarray represents a clause, and the top level structure
is an array of clauses. This is written to a temporary file which
is fed into the All-SAT solver, where we receive the same format as
a result. The actual variable states are represented in an array of
bit vectors. Formally each state is represented as $\{V_{0},V_{1},\ldots\,,V_{m}\}$
where $V_{m}=\{0,1,2,\ldots\,,n\}\{0,1\}$ where \emph{m} is the number
of clauses, and \emph{n} is the number of variables in each clause.
This is logically equivalent to DNF, where each vector is a disjunction
of clauses, and each clause is the conjunction of an ordered list
of assignments to variables at their respective indices. Since every
assignment is packed efficiently, it enables builtin bitwise operations
such as masking, as well as SIMD operations which can greatly increase
processing time on individual clauses. This is exploited in the distance
calculation, since the Hamming Distance of two bit vectors can be
efficiently computed by performing an XOR on the two vectors, and
counting the resultant bits. On modern x64 architechtures, there are
extended registers covering 128, 256, and even 512 bits, which can
perform the XOR faster than individually applying it to bytes or machine
words. There is also a dedicated instruction known as POPCNT, which
calculates the number of set bits in a register. This is the primary
reason for representing belief states as bit vectors, since the distance
calculation can quickly be accomplished with 2 dedicated hardware
instructions. The other aspect used in creating an efficient runtime
is the use of parallelism. Our solver heavily employs OpenMP to add
worksharing across multiple cores to our workloads, to the point that
the vast majority of the belief revision process is executed in parallel.
There are very few data dependencies in the data or the algorithms,
so aspects such as distance calculations and generated state padding
can be executed in parallel with minimal synchronization. The primary
limiting factor for our solver is the fundamental scale of solutions
returned from the All-SAT solver. When testing with a variety of 3-SAT
formula inputs with 100 variables, the range of possible solutions
ranged from 200 to well over 7000, depending on the individual input.
When attempting to solve formulas with 250 variables, the total number
of solutions increased to over 38 million, and required more than
40 GB on disk. When the solutions are padded properly to match the
belief state inputs, the total number of generated states becomes
computationally infeasible to manipulate. We have attempted to create
an efficient implementation of a belief revision solver, but without
algorithmic improvements on All-SAT, the potential scaling of our
solver is limited.

\section{Conclusion}

Our new belief revision solver is a scalable and efficient tool, designed
around hardware-friendly parallel data structures, and utilizing an
All-SAT solver for enumerating the list of satisfying clauses to the
revision formula. Our tool can easily handle revision formulae with
100 variables, and will scale well with moreprocessing cores. Fundamentally,
the limiting factor for our solver is the scale of solutions returned
from the All-SAT solver, requiring algorithmic improvements if we
are to exceed our current limits.
\end{document}
